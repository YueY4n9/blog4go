---
title: 面试经验
date: 2021-05-31 15:07:04
tags:
---

> 2021-05-31

### 我在项目中遇到的难点

- 地图切片的分组缓存
- 负责集成LiquiBase

> 2021-06-02

### 了解HashMap吗？

- HashMap的数据结构（数组+链表/红黑树）
- 哈希冲突的实现原理
- HashMap扩容机制
- 线程不安全性
- HashMap为什么初始容量是2的4幂（16）：按位运算

### 那想用线程安全的Map用什么呢？（踩过坑）

我答的ConcurentHashMap是线程安全的，并且把线程安全的机制详细的描述了一遍；但是我记忆里大学期间学过了一段设计，就是说ConcurrentHashMap也不是完全保证线程安全的，在事务下，也会发生线程不安全。当时对ConcurrentHashMap的理解也仅限于此；但今天细究了一下，ConcurrentHashMap是可以完全保证每次操作的线程安全问题的，但是事务的安全那就得另算了，需要考虑的就是事务的隔离级别了！这点希望大家不要和我一起进入这个误区。过段时间会详细写一下事务的隔离级别的专题文章。

### 了解MySQL索引吗？

- 索引的数据结构（B+树）
- B+树的自平衡（脑子清楚嘴笨）
- 

### 算法题：数组中求最大差值（股票的最大收益问题）

这题朴实无华的动态规划，2分钟解决了。

```java
//    public static void main(String[] args) {
//        int[] nums;
//        nums = new int[0];
//        System.out.println(question1(nums));
//        nums = new int[]{1};
//        System.out.println(question1(nums));
//        nums = new int[]{21, 12, 7, 3, 11, 20};
//        System.out.println(question1(nums));
//        nums = new int[]{21, 20, 19, 18, 10};
//        System.out.println(question1(nums));
//        nums = new int[]{22, 20, 20, 20, 10};
//        System.out.println(question1(nums));
//    }

    /**
     * 动态规划实现, 如果按照题意求最大差值的话需要返回零和负数情况
     */
    public static int question1(int[] nums) {
        int len = nums.length;
        if (len < 2) {
            return 0;
        }
        int min = Math.min(nums[0], nums[1]);
        int max = nums[1] - nums[0];
        for (int i = 2; i < len; i++) {
            if (nums[i] - min > max) {
                max = nums[i] - min;
            }
            if (nums[i] < min) {
                min = nums[i];
            }
        }
        return max;
    }
```

### 算法题：计算合法`（）`的最大长度

？？？这连中间都不穿插点加减号了？？？

直接上代码

```java

//    public static void main(String[] args) {
//        String str;
////        str = "()()()()";
////        System.out.println(question2(str));
////        str = "((((()()";
////        System.out.println(question2(str));
//        str = "()(())";
//        System.out.println(question2(str));
//        str = "(()))))())";
//        System.out.println(question2(str));
//        str = "((((";
//        System.out.println(question2(str));
//        str = ")))((()((((()((";
//        System.out.println(question2(str));
//        str = "(*(*)*)*)(())";
//        System.out.println(question2(str));
//    }

    /**
     * 栈使用的问题
     */
    public static int question2(String str) {
        int result = 0;
        if (null == str)
            return 0;
        Stack<Integer> stack = new Stack<>();
        int start = 0;
        for (int i = 0; i < str.length(); i++) {
            if ('(' == str.charAt(i)) {
                stack.push(i);
            } else {
                if (stack.isEmpty()) {
                    start = i + 1;
                } else {
                    stack.pop();
                    if (stack.isEmpty()) {
                        result = Math.max(result, i - start + 1);
                    } else {
                        result = Math.max(result, i - stack.peek());
                    }
                }
            }
        }
        return result;
    }
```

### 算法题：实现LRU算法

这题我是最喜欢的^_^因为我脑子会，手不会写（我就想知道谁能记住LinkedHashMap里面的API啊），所以百度帮我做了，但想法我就是这样的。

给大家讲一下实现吧，首先LRU就叫做Least Recently Used最少最近使用，就是把最老最久没碰过得数据给淘汰掉，刚好LinkedHashMap就已经做了按照访问顺序来实现节点排序，HashMap的put方法有一个实现，参数是accessOrder，当accessOrder=true时，访问节点和插入节点都会将当前节点放到链表最新处（如果是JDK1.6+那就是放到结尾去），那不就是LRU的想法么 ~ 那我直接用就好了（源码解析我7月份会贡献笔记）

```java
    /**
     * LRU算法：最少最近使用：利用LinkedHashMap实现了按访问顺序存储的特性来简单实现
     */
    static class LRUCache<K, V> {
        private static final float loadFactor = 0.75f;
        private LinkedHashMap<K, V> map;
        private int initialCapacity;

        public LRUCache(int cacheSize) {
            this.initialCapacity = cacheSize;
            int capacity = (int) Math.ceil(cacheSize / loadFactor) + 1;
            // accessOrder=true是重点, 该参数为true是按照访问顺序插入到链表最新节点后, false是按照插入顺序存储
            map = new LinkedHashMap<K, V>(capacity, loadFactor, true) {

                @Override
                protected boolean removeEldestEntry(Map.Entry eldest) {
                    return size() > LRUCache.this.initialCapacity;
                }
            };
        }

        public synchronized V get(K key) {
            return map.get(key);
        }

        public synchronized void put(K key, V value) {
            map.put(key, value);
        }
    }
```



### 设计一个门票限时销售系统

听到这个题目我直接懵圈了，what？我设计一个系统？

提供系统架构图和业务流程图，what？画图？

这个考的不是我的专业技能，是对总体把控的能力，但我觉得我现在还不是把精力去花费在把一个个专业知识整合的时候，我更应该做的是去精通和扎实每一个我熟悉的技术（听起来像是在给自己找理由，嘻嘻），所以这题我就简单答了答，做了一个微服务，订单和商品的并发操作使用Redis的分布式锁保证安全，然后限时功能也是就用Redis的设置存活时间来实现。

