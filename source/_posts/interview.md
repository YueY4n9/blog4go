---
title: 面试总结
date: 2021-05-31 15:07:04
tags:
  - 总结
  - 面试
---

> 整理了面试过程中个人遇到的问题, 并附带了 chatgpt 的回答. 希望能对个人提升和习惯养成有所帮助.

<!--more-->

> 2023年04月11日23:13:39

mihoyo 面试准备内容

- go 里面使用 map 时应注意问题和数据结构?
- go map 如何扩容?
- 哈希分桶的结构，用哈希值的高八位和低八位分别来做桶内定位的依据和分桶的依据等
- map 的 panic 能被 recover 掉吗? 了解 panic 和 recover 的机制吗?
- map 怎么知道自己处于竞争状态? 是 go 编码实现的还是底层硬件实现的?
- cas 具体是怎么实现的呢?
- 并发使用 map 除了加锁还有什么其他方案吗?
- 有对比过 sync.Map 和加锁的区别吗?
- 说一下 redis 分布式锁的实现?
- 基于 redis 的分布式锁会有什么问题?
- redis 分布式锁超时可以超时时间设长一点可以吗?不可以的话需要怎么解决?
- 对 redis 锁续期这个怎么实现呢?
- 日常在用的 redis 集群都是什么架构?在主从模式和 redis Cluster 中分布式锁会有什么问题?

> 2023年04月11日22:44:12

### goroutine 并发问题一般怎么处理

goroutine 并发问题的处理方法可以有多种，常见的包括以下几个方面：

1. 互斥锁：通过在临界区（共享资源）的访问前加锁，在访问完后释放锁，来保证同一时刻只有一个 goroutine
   访问该资源。这是最基本也是最常用的并发控制手段。

2. 通道（channel）：goroutine 可以通过通道来进行数据交换和同步，通道会自动进行同步和阻塞，从而避免竞争条件和死锁问题。

3. WaitGroup：通过 WaitGroup 来等待一组 goroutine 全部完成任务，可以避免并发中处理未完成的任务。

4. 原子操作：原子操作是指不可分割的操作，它可以保证对于同一共享资源的操作是原子的，不会出现并发问题。在
   Go
   中，使用 atomic 包提供的原子操作可以很方便地解决一些常见的并发问题，如计数器增减等。

5. Select 语句：Select 语句可以使 goroutine 阻塞在多个通道上，从而实现多路复用和超时等功能。

需要注意的是，并发编程需要特别小心处理各种细节，一定要保证代码正确性和可靠性。例如，避免死锁、竞争条件、资源泄露等问题，需要对并发编程有一定的深度理解和实践。

### 介绍一下你理解的 DDD, 说说领域驱动的优缺点

- DDD 的优点：
    - 更好地理解业务领域：DDD 强调对业务领域的深入理解和建模，使得开发团队更加了解业务需求和问题，并有助于构建更符合业务需求的软件系统。
    - 更好的代码组织结构：DDD 强调分层架构，并且在领域驱动设计中使用聚合根以及其它概念，使用这些技术可以帮助我们划分更清晰的代码组织结构，易于扩展和维护。
    - 更好的模块化和可重用性：DDD 的模块可以独立开发、测试、部署和维护，这增强了代码和库的可重用性。
    - 更好的代码质量：DDD 在代码设计和实现方面注重质量和可测试性，强调软件的可读性和可维护性，有助于减少代码漏洞和提高软件质量。
    - 更容易与领域专家协作：DDD 鼓励开发团队与领域专家紧密合作，共同理解业务需求和问题，确保软件系统符合业务需求。
- DDD 的缺点：
    - 初始成本较高：使用 DDD 时需要时间和精力来理解业务领域以及进行领域建模和设计，这需要一定的成本和资源才能实现。
    - 不适用于所有项目：DDD 更适用于大型复杂软件系统，对于小型简单项目可能会显得过于繁琐和复杂。
    - 需要高水平的技能：使用 DDD 需要开发人员具备领域建模、业务分析和软件设计等方面的高水平技能，否则可能会造成代码质量不佳的问题。
    - 架构复杂度高：DDD 引入了很多概念和技术，可能会增加架构的复杂度和难度。
    - 协作开发成本高

### go 切片线程安全吗? 安全的话为什么安全? 不安全的话为什么不安全? 如果保证线程安全?

go 切片本身是线程不安全的

在 Go 中，切片是引用类型，底层结构包括指向底层数组的指针、切片长度和容量等信息。当多个协程或线程同时对同一个切片进行操作时，可能会发生数据竞争，导致程序出现不可预期的结果。

如果要保证切片的线程安全，可以采用以下方法：

1. 使用互斥锁（Mutex）来保护切片访问：在对切片进行读写操作前，先获取互斥锁，操作完成后释放锁。这种做法能够保证同一时间只有一个协程可以访问切片，从而避免了数据竞争问题。
2. 使用读写锁（RWMutex）进行保护：如果对于切片的读取操作比写入操作更频繁，可以使用读写锁来提高效率。读写锁允许多个协程或线程同时读取切片，但只允许一个协程或线程进行写入操作。
3. 使用通道（channel）来控制协程访问：可以将切片转换成通道，通过在通道上发送和接收数据来达到同步的目的。在此情况下，只能有一个协程写入切片，其他协程需要等待写入完成才能去访问。
4. 不共享切片(我只想说这是个逆天方法)：在并发环境下，可以将切片复制一份，每个协程对自己的副本进行读写操作，从而避免了多个协程访问同一个切片的问题。

```markdown
个人理解：slice 是引用类型，底层指向的数组是值类型，数组本身是线程安全的，但切片涉及到了扩容，导致了切片并不是线程安全的。
```

> 2023年04月10日17:25:23

### go map 并发不安全的表现

在 Go 中使用 map 存储数据时，如果多个协程同时对同一个 map 进行读写操作，会导致数据不一致。常见的表现有以下几种：

1. 写入冲突：如果两个或多个协程同时对同一个 map 的某个 key 进行写入操作，会出现竞争条件，容易导致数据被覆盖或漏写。

2. 读写冲突：如果一个协程正在写入 map，而另外一个协程同时读取 map，可能会读到不一致的数据。

3. 事件顺序混乱：如果多个协程同时对同一个 map 进行读写操作，那么事件的执行顺序可能会混乱，这也可能导致数据不一致的情况。

为了解决这些问题，Go 提供了如下几种方案：

1. 加锁：使用 Mutex 或者 RWMutex 来保证 map 的并发安全，确保只有一个协程对 map 进行读写操作。

2. 使用 sync.Map：sync.Map 是 Go 1.9 引入的，它提供了一种并发安全的
   map，内部实现了读写锁和单独的实例存储机制，可以在并发环境下安全地进行读写操作。

3. 使用 channel：通过 channel 来协调各个协程的读写操作，确保每个协程都能够正确地读写数据，从而避免竞争条件。

综上所述，Go 中的 map 在并发操作时可能会出现不安全的情况，需要使用加锁、使用 sync.Map 或者使用 channel
等方案来确保其安全性。

### go context.Context 使用场景

在 Go 中，context.Context 是一种用来传递请求特定的数据、取消协程的机制，它可以被用于多种场景，包括以下几个方面：

1. 协程间传递参数：在 Go 中启动一个协程很容易，但是如何向协程中传递参数就需要采用 context.Context 了。通过
   WithValue 方法，可以将一些请求特定的数据传递到下游协程中，从而简化代码实现。

2. 控制超时/取消：context.Context 提供了 Deadline 和 Cancel
   方法，可以在指定时间或特定时机完成对协程的取消操作，从而避免程序因为等待某些资源而陷入死锁状态。

3. 链路追踪：context.Context 可以被用于链路追踪，通过在 context 中注入 TraceID、SpanID
   等信息，可以实现全链路跟踪和监测。

4. 限制资源：context.Context 也可以被用于限制资源，例如数据库连接池中的最大连接数，通过使用
   context.WithTimeout 和 context.WithDeadline 方法，可以确保在超过预设的时间后，不再向连接池中请求连接，从而避免连接池溢出。

5. 处理错误：在处理请求时，可能会发生错误，这个时候可以通过传递一个被取消的 context
   来通知下游协程退出，同时上游协程可以收到这个错误并进行处理。

综上所述，context.Context 可以用于多种场景，包括协程间传递参数、超时/取消控制、链路追踪、资源限制和错误处理等。使用
context.Context 能够帮助我们更加优雅地实现代码逻辑，提高可维护性，并减少因为超时、死锁等问题带来的系统异常。

### 线程中阻塞有哪些方式?

1. channel 阻塞: 当一个 goroutine 向一个已满的 channel 中写入数据或一个空 channel 中读取数据时，会发生阻塞。这时
   goroutine 会暂停执行，等待其他 goroutine 从 channel 中读取或写入数据，从而使得自己可以继续执行。
2. Mutex 互斥锁阻塞: 在访问共享资源时，需要加锁来避免数据竞争。当一个 goroutine 访问到被 Mutex
   锁住的共享资源时，如果 Mutex 被其他 goroutine 锁住了，当前 goroutine 就会阻塞在 Lock 操作上，等待
   Mutex 解锁。
3. WaitGroup 阻塞：WaitGroup 可以用于等待多个 goroutine 的完成。在调用 WaitGroup 的 Wait 方法时，当前
   goroutine 会阻塞在 Wait 方法上，直到计数器归零。
4. Timer 阻塞：在某个时间点触发某个操作，需要使用 Timer。Timer 的 C 成员变量通常会阻塞当前
   goroutine，直到定时器到期后才能继续执行。

### mysql mongo 应用场景

- mysql
    1. 需要高度事务支持的应用
    2. 数据量大、数据结构稳定(不容易扩展的表)
    3. 复杂查询较多的场景
- mongo
    1. 高度可扩展的
    2. 结构松散(json格式): 数据格式多样化，结构相对松散的应用：MongoDB 是文档型数据库，支持非常灵活的数据格式和动态的数据结构。这使得
       MongoDB 更适合于数据结构相对自由的应用，例如社交网络、博客平台、物联网等。
    3. 需要实时数据处理和分析的应用：MongoDB 支持内置的 MapReduce
       和聚合框架，能够高效地进行数据分析和处理。此外，它还提供了全文检索和地理空间查询等功能，非常适合需要实时分析和处理数据的应用。

### mysql 慢查询怎么处理?

MySQL 慢查询是指执行时间较长的 SQL 查询语句，可能会对系统性能和响应时间造成影响。通常情况下，长时间查询是由于
SQL 语句写法不当、查询条件错误或者数据量过大等原因导致的。

以下是处理 MySQL 慢查询的方法：

1. 开启慢查询日志：通过在 MySQL 配置文件中开启慢查询日志（slow_query_log），MySQL 会记录执行时间超过设定阈值的
   SQL 语句，并将其保存到日志文件中。可以利用这些记录来优化性能较慢的查询语句。

2. 分析查询语句：可以使用 EXPLAIN 关键字查看查询语句的执行计划，以确定是否需要添加索引或者优化查询语句。

3. 优化查询语句：通过调整查询语句的写法、缩小查询范围等手段来尽量减少查询返回的结果集大小，从而提升查询速度。

4. 添加索引：索引可以加速查询操作，但是过多、重复或者不合理的索引会带来额外的开销。因此，在添加索引前需要理性分析数据表的结构和访问模式。

5. 优化 MySQL 参数：通过配置 MySQL 中的参数（如max_connections，query_cache_size 等）来提高 MySQL 的性能。

6. 升级硬件：如果以上方法都无法解决慢查询问题，可以考虑升级硬件（如更换 CPU、加大内存、升级硬盘等）来提高系统性能。

以上是处理 MySQL 慢查询的常用方法，需要综合考虑应用场景和具体情况来选择最优的解决方案。

### redis 雪崩是什么?怎么解决?

redis 雪崩是指 redis 缓存中大量的 key 在同一时间失效或者过期，导致瞬时请求全部落在数据库上，从而引起数据库性能问题、甚至宕机的现象。通常情况下，redis
雪崩是由于系统设计不合理、缺乏容错机制、缓存框架异常等原因导致的。

以下是处理 redis 雪崩的方法：

1. 设置过期时间随机化：可以通过给 redis 中的 key 设置随机过期时间，避免大量的 key 同一时间过期。例如，可以在
   redis 中设置一个过期时间的范围，在这个范围内随机生成一个时间来设置过期时间。

2. 缓存预热: 可以通过缓存预热的方式，提前将部分常用的 key 加载到 redis 缓存中，避免一次性访问大量数据库，从而减轻数据库负担。

3. 数据库限流：可以通过设置连接数、并发数等参数，限制数据库的最大请求频率，避免大量请求同时打到数据库上，导致宕机。

4. 加强监控：要对 redis 的运行情况进行监控，包括 key 过期时间、内存使用情况等信息，以便及时发现异常和预测故障。

5. 分布式部署：将 redis 集群化，将数据分散到多个 redis 节点上，可以降低单个节点的负载，提高系统的容错性。

6. 备份和恢复：定期备份 redis 数据，保证在 redis 宕机或者数据错误的情况下可以快速恢复数据，减少故障恢复时间。

综上所述，通过设置过期时间随机化、缓存预热、数据库限流、加强监控、分布式部署和备份和恢复等方法，可以有效地解决
redis 雪崩问题，并提高系统的稳定性和可靠性。

### redis 分布式锁的上限如何设置?

在 redis 中实现分布式锁时，可以考虑使用 SETNX（SET if Not
eXists）指令。但是，当多个客户端同时竞争同一个锁时，会导致竞争激烈，从而导致大量的锁请求超时，影响系统性能。

为了避免这种情况，可以给分布式锁添加一个过期时间（即锁的最大持续时间），当锁到期之后自动释放。但是，需要合理地设置锁的过期时间，以避免太短影响业务操作，太长则可能导致死锁等问题。

一般来说，锁的过期时间应该根据业务特点和数据处理时间来确定。例如，如果业务数据处理时间在 10 秒钟内完成，可以设置
15 秒的过期时间；如果业务数据处理时间较长，可以适当延长过期时间。但是，过长的过期时间会增加单点故障的风险，因此需要综合考虑。

除了设置过期时间外，还可以考虑引入 Redlock 算法、基于 Lua
脚本实现分布式锁等技术，以提高分布式锁的稳定性和可靠性。但是，需要根据具体情况进行选择和实现。

> 2021-07-22

### TCP/UDP区别

TCP向上层提供面向连接的可靠服务 ，UDP向上层提供无连接不可靠服务

虽然 UDP 并没有 TCP 传输来的准确，但是也能在很多实时性要求高的地方有所作为

对数据准确性要求高，速度可以相对较慢的，可以选用TCP

### Zookeeper是什么框架

Zookeeper是分布式系统协调服务的框架，也叫作服务注册中心

### Dubbo一般用什么注册中心?还有别的选择吗?

Dubbo一般使用Zookeeper，也可以使用redis，consul，数据库

### 为什么说Spring是一个容器?

Spring的核心思想是更方便的管理Java Bean，有Spring创建的Bean放入一个Map中，这个Map就可以理解成装Bean的容器，也就是IOC容器。

### JVM生命周期和体系结构

JVM声明周期是跟随程序一起的，JVM开始运行时就是程序启动时，JVM停止运行程序也随之结束。

JVM体系结构包含：类加载器、内存区、执行引擎、本地方法调用。

> 2021-06-07

### ConcurrentHashMap为什么是CAS+Synchronized?

用CAS是为了减小锁的粒度，毕竟CAS是JUC下面使用最多的锁，用Synchronized是因为Synchronized可以不断优化，并且粒度也不高。

### MyBatis是怎么实现的?不用Spring怎么集成?

### CAS会出现什么问题?怎么解决的?

ABA问题

### MySQL和redis的重要数据，必须完全一致，这个怎么实现?

### MySQL是可重复读是怎么实现的?

使用MVCC（多版本并发控制），每次SELECT之前会找到上一个数据版本，只读当前版本的数据。innoDB已经实现"
秒级快照版本"

### springboot做了哪些事?深入到底层是怎么实现的?

### redis的Key过期后会立即删除么?

不会的，三种删除策略：定时删除、惰性删除（?还有什么?原理是什么）

### redis的集群用过吗?是怎么的架构?哨兵机制呢?

### 分布式集群下怎么执行定时任务?

### 为什么分布式要用RestTemplete而不用HttpUtils?

### JWT的整体流程是怎样的?

MySQL锁
redis集群

> 2021-06-04

### maven父类依赖冲突

maven的依赖原则

### 线城池参数、拒绝策略、流程

7个参数：核心线程数、总线程数、存活时间、时间单位、阻塞队列、工厂、拒绝策略

4个拒绝策略：拒绝并抛出异常、静默拒绝、移除队列中最前面的任务然后重新提交被拒绝的任务、由调用线程来执行该任务

流程：先看核心线程是否满了，满了再看阻塞队列是否满了，满了再看总线程数是否满了，满了再走拒绝策略

### ConcurrentHashMap的线程安全在JDK1.7和JDK1.8的区别

JDK1.7：分段锁

JDK1.8 :  Synchronized+CAS

### SpringMVC工作流程（需要仔细研究底层执行流程）

1. 客户端发送请求到前端控制器DispatcherServlet
2. 前端控制器DispatcherServlet根据URL来决定选择哪一个控制器Controller进行处理，并把请求委托给控制器
3. 控制器Controller接收请求后，将请求参数绑定为一个对象，这个对象叫命令对象，并进行验证。然后将命令对象委托给业务对象进行处理，处理完毕后返回一个ModelAndView
4. 前端控制器DispatcherServlet收回控制权，然后根据返回的逻辑视图名，选择相应的视图进行渲染，并把模型数据传入，以便渲染
5. 前端控制器DispatcherServlet再次收回控制权，将相应返回给用户

### 类加载过程

加载、验证、解析、准备、初始化

### 了解双亲委派机制吗?

一个类加载器加载类时，会将请求委托交给父加载器去加载，只要父加载器无法完成这个加载请求时，子加载器才会自己尝试完成加载。

好处：保证基础类环境的稳定运行

> 2021-06-03

### spring和springboot的区别

springboot就是spring的扩展，少了繁琐的配置，让开发、测试、部署方便了。

> 2021-06-02

### 了解HashMap吗?

- HashMap的数据结构（数组+链表/红黑树）
- 哈希冲突的实现原理
- HashMap扩容机制
- 线程不安全性
- HashMap为什么初始容量是2的4幂（16）：按位运算

### 那想用线程安全的Map用什么呢?（踩过坑）

我答的ConcurrentHashMap是线程安全的，并且把线程安全的机制详细的描述了一遍；但是我记忆里大学期间学过了一段设计，就是说ConcurrentHashMap也不是完全保证线程安全的，在事务下，也会发生线程不安全。当时对ConcurrentHashMap的理解也仅限于此；但今天细究了一下，ConcurrentHashMap是可以完全保证每次操作的线程安全问题的，但是事务的安全那就得另算了，需要考虑的就是事务的隔离级别了！这点希望大家不要和我一起进入这个误区。过段时间会详细写一下事务的隔离级别的专题文章。

### 了解MySQL索引吗?

- 索引的数据结构（B+树）
- B+树的自平衡（脑子清楚嘴笨）
- MySQL索引能存储的数据量
- 事务的基本要素ACID
- 事务并发问题：脏读、不可重复读、幻读
- 事务的隔离级别（读未提交、不可重复读、重复读、串行化）

### 算法题：数组中求最大差值（股票的最大收益问题）

这题朴实无华的动态规划，2分钟解决了。

```java
//    public static void main(String[] args) {
//        int[] nums;
//        nums = new int[0];
//        System.out.println(question1(nums));
//        nums = new int[]{1};
//        System.out.println(question1(nums));
//        nums = new int[]{21, 12, 7, 3, 11, 20};
//        System.out.println(question1(nums));
//        nums = new int[]{21, 20, 19, 18, 10};
//        System.out.println(question1(nums));
//        nums = new int[]{22, 20, 20, 20, 10};
//        System.out.println(question1(nums));
//    }

    /**
     * 动态规划实现, 如果按照题意求最大差值的话需要返回零和负数情况
     */
    public static int question1(int[] nums) {
        int len = nums.length;
        if (len < 2) {
            return 0;
        }
        int min = Math.min(nums[0], nums[1]);
        int max = nums[1] - nums[0];
        for (int i = 2; i < len; i++) {
            if (nums[i] - min > max) {
                max = nums[i] - min;
            }
            if (nums[i] < min) {
                min = nums[i];
            }
        }
        return max;
    }
```

### 算法题：计算合法`（）`的最大长度

???这连中间都不穿插点加减号了???

直接上代码

```java

//    public static void main(String[] args) {
//        String str;
////        str = "()()()()";
////        System.out.println(question2(str));
////        str = "((((()()";
////        System.out.println(question2(str));
//        str = "()(())";
//        System.out.println(question2(str));
//        str = "(()))))())";
//        System.out.println(question2(str));
//        str = "((((";
//        System.out.println(question2(str));
//        str = ")))((()((((()((";
//        System.out.println(question2(str));
//        str = "(*(*)*)*)(())";
//        System.out.println(question2(str));
//    }

    /**
     * 栈使用的问题
     */
    public static int question2(String str) {
        int result = 0;
        if (null == str)
            return 0;
        Stack<Integer> stack = new Stack<>();
        int start = 0;
        for (int i = 0; i < str.length(); i++) {
            if ('(' == str.charAt(i)) {
                stack.push(i);
            } else {
                if (stack.isEmpty()) {
                    start = i + 1;
                } else {
                    stack.pop();
                    if (stack.isEmpty()) {
                        result = Math.max(result, i - start + 1);
                    } else {
                        result = Math.max(result, i - stack.peek());
                    }
                }
            }
        }
        return result;
    }
```

### 算法题：实现LRU算法

这题我是最喜欢的^_^因为我脑子会，手不会写（我就想知道谁能记住LinkedHashMap里面的API啊），所以百度帮我做了，但想法我就是这样的。

给大家讲一下实现吧，首先LRU就叫做Least Recently
Used最少最近使用，就是把最老最久没碰过得数据给淘汰掉，刚好LinkedHashMap就已经做了按照访问顺序来实现节点排序，HashMap的put方法有一个实现，参数是accessOrder，当accessOrder=true时，访问节点和插入节点都会将当前节点放到链表最新处（如果是JDK1.6+那就是放到结尾去），那不就是LRU的想法么 ~
那我直接用就好了（源码解析我7月份会贡献笔记）

```java
    /**
     * LRU算法：最少最近使用：利用LinkedHashMap实现了按访问顺序存储的特性来简单实现
     */
    static class LRUCache<K, V> {
        private static final float loadFactor = 0.75f;
        private LinkedHashMap<K, V> map;
        private int initialCapacity;

        public LRUCache(int cacheSize) {
            this.initialCapacity = cacheSize;
            int capacity = (int) Math.ceil(cacheSize / loadFactor) + 1;
            // accessOrder=true是重点, 该参数为true是按照访问顺序插入到链表最新节点后, false是按照插入顺序存储
            map = new LinkedHashMap<K, V>(capacity, loadFactor, true) {

                @Override
                protected boolean removeEldestEntry(Map.Entry eldest) {
                    return size() > LRUCache.this.initialCapacity;
                }
            };
        }

        public synchronized V get(K key) {
            return map.get(key);
        }

        public synchronized void put(K key, V value) {
            map.put(key, value);
        }
    }
```

### 设计一个门票限时销售系统

听到这个题目我直接懵圈了，what?我设计一个系统?

提供系统架构图和业务流程图，what?画图?

这个考的不是我的专业技能，是对总体把控的能力，但我觉得我现在还不是把精力去花费在把一个个专业知识整合的时候，我更应该做的是去精通和扎实每一个我熟悉的技术（听起来像是在给自己找理由，嘻嘻），所以这题我就简单答了答，做了一个微服务，订单和商品的并发操作使用redis的分布式锁保证安全，然后限时功能也是就用redis的设置存活时间来实现。

> 2021-06-01

### 算法题：求100以内质数的阶乘之和

思路是先求100以内的阶乘，放到数组中，再对数组中的质数一一求阶乘，再累加；

思路清晰，但编码过程中我发现了两个问题，一个就是10以上的阶乘其实是非常大的，那么他们的和很可能超过int和long的范围，所以尽可能使用其他更能长的数据结构来存储。果然，97的阶乘甚至都到达了

```java
// 96192759682482119853328425949563698712343813919172976158104477319333745612481875498805879175589072651261284189679678167647067832320000000000000000000000
```

那么就先用BigDecimal来试试够不够，上我的代码

```java
    /**
     * 题目2
     */
    private static void question2() {
        // 保存质数结果集
        List<Integer> list = new ArrayList<>();
        for (int i = 2; i <= 100; i++) {
            // 判断当前数字是否为质数
            if (isPrimeNumber(i)) {
                // 将质数添加到结果集
                list.add(i);
            }
        }
        // 打印质数结果集, 为question5参考
        list.forEach(System.out::println);
        // 返回结果超出long长度, 使用BigDecimal保存最终结果和计算过程结果
        BigDecimal result = new BigDecimal(0);
        for (int num : list) {
            // 顺序添加BigDecimal类型的阶乘结果
            result = result.add(getBigDecimalFactorial(num));
        }
        System.out.println("结果:" + result); 
    }

    /**
     * 判断一个2-100的数字是否是质数
     */
    private static boolean isPrimeNumber(int num) {
        if (num == 2) return true;
        for (int i = 2; i <= Math.sqrt(num); i++) {
            if (num % i == 0) {
                return false;
            }
        }
        return true;
    }

    /**
     * 计算一个1-100之间数字的阶乘
     * 返回结果超过long长度, 使用BigDecima保存过程结果
     */
    private static BigDecimal getBigDecimalFactorial(int num) {
        BigDecimal result = new BigDecimal(num);
        for (int i = 2; i < num; i++) {
            result = result.multiply(new BigDecimal(i));
        }
        System.out.println(num + "的阶乘是" + result);
        return result;
    }
```

运气不错，BigDecimal就存下了。但如果是BigDecimal也存储不下的话，就用String来存吧，就是要重写一个加减乘除方法来实现就比较麻烦了。

### 智力题：23枚硬币中10枚是朝上的，分两堆怎么实现朝上的硬币一样多

这题我采用的数学的方式解决，也是需要转个弯就解决了。

```markdown
# 设一堆中朝上硬币是x, 另一堆则是10-x

# 那我需要做的令 x = 10-x

# 那么问题就来了, 错误的逻辑是让 x = 5, 思考无果后换个方向

# 如果还有一个10-x的变量, 那么尝试着解决交换变量种类可不可以

# 百度：如果令一堆硬币是10, 翻转这10枚硬币, 就可以了（啊啊啊, 我的思路没错, 就差一点点）
```

### 证明题：中间只隔一个数字的两个质数数被称为质数对，比如17和19。证明质数对之间的数字总能被6整除

这个话不多说了，我思路都在我的回答上了

```java
    private static void question5() {
        // 1 3 中间这个数字是2, 这个数字需要大于6*********************************
        // 2 4 不可能2结尾, 因为所有2结尾的数字都可以被2整除
        // 3 5 不可能5结尾, 因为所有5结尾的大于6的数字都可以被5整除(15, 25, 35)
        // 4 6 不可能4结尾, 因为所有4结尾的数字都可以被2整除
        // 5 7 不可能5结尾, 因为所有5结尾的大于6的数字都可以被5整除(15, 25, 35)
        // 6 8 不可能6结尾, 因为所有6结尾的数字都可以被2整除
        // 7 9 中间这个数字是8, 这个数字需要大于6***************************************
        // 8 0 不可能8结尾, 因为所有8结尾的数字都可以被2整除
        // 9 1 中间这个数字是0, 这个数字需要大于6*********************************
        // 0 2 不可能0结尾, 因为所有0结尾的数字都可以被5整除
        // 根据星号“*****”行的分析可知
        // 根据我的上面这个分析, 只需要证明这个数字一定可以被2整除, 那么该命题就可以转换成去证明这个数字可以被3整除
        // 假设质数对数字为x, x-1, x+1分别是质数
        // 而且x-1和x+1都是大于6的质数, 那么x-1不可能被三整除, 要么余1, 要么余2, 同理可知x+2, 要么余1, 要么余2
        // 并且关键是x-1与x+1之间只差了2, 所以这两个质数的余数一定是一个余1, 一个余2
        // 那么假设x不可能被3整除, 那么一定余1或者余2, 无论如何都是x+1和x-1余1余2的条件矛盾
        // 所以x一定可以被3整除
        // 最后得到结论, 质数对之前的数字一定可以被6整除
    }
```

百度的答案稍微复杂点，我是拆解了6，感觉更容易理解一些。

> 2021-05-31

### 我在项目中遇到的难点

- 地图切片的分组缓存
- 负责集成LiquiBase