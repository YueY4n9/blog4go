### 2021

#### 202106

##### 20210628

api/http/v1： `handler.go`定义uri与代码的映射、入参校验，调用`Service层`的逻辑写在这里面；`validation.go`定义入参校验的结构体

context：`config.go`、`context,go`配置文件

domain：`domain.go`实现`interface.go`，

microservice：未知

model：未知

router：路由层，程序启动时初始化用到的`路由层`

service：`service.go`实现`interface.go`，service.go里写逻辑调用的其他模块的一个service结构体，实现调用`数据层`的所有逻辑，数据层包含`domain`和`entity`两部分，分别代表DAO层和Entity层，把domain下来操作数据库，得到entity，entity来获取数据库实例中具体信息



>   总结：handle层→service层→domain层

##### 20210629

包中引用多个其他功能同级目录的包导致的重命名规则

>   功能模块名简写+当前目录层级名简写，全部字母小写；
>
>   当不同功能模块简写重复时，后添加的功能模块包使用易懂的简写代替；

```go
import{
    uc "powerlaw.ai/meflow/controller/internal/app/utils/consts/user" // uc表示userconsts
}
```

包中引用系统级别包和自定义包导致的重命名规则

>   系统级别包使用前缀`sys`+包名或缩写
>
>   Golang扩展包使用`go`或扩展包前缀+包名或缩写
>
>   用户自定义包使用原名或缩写，全部字母小写；

```go
import{
    sysctx 	"context"
    
   	gouuid "github.com/satori/go.uuid"
    gomail "gopkg.in/mail.v2"
    
    context "powerlaw.ai/meflow/controller/internal/app/domain/contract/entity"
}
```

包中引用工具包，可以直接重定义命名

>   引用工具包时，即使没有重名包的情况下，对工具包直接重命名，全部字母小写；

```go
import{
    httputils "powerlaw.ai/meflow/controller/internal/app/utils/http" 
}
```

>   结构体中引用到多个其他其他功能同级目录的类型时，参数名使用功能模块名+目录层级名，小驼峰命名（包名中包含多词时以功能为最小单位）
>
>   引用到系统级别包或自定义系统级功能包时，
>
>   当`单词长度≤8`时，参数名可以使用单词全拼；
>
>   当`单词长度＞8`时，参数名使用短命名形式；

```go
type service struct {
    ctx 				*context.AppContext	// AppContext就简写成ctx
    workflowDomain 		workflow.Domain		// workflow长度适宜，使用全拼，且不允许写成workFlow
    bcDomain 			bcd.Domain 			// businesscategory过长，就简写成了bc
}
```

git rebase相关

```shell
git checkout -b [本地开发分支名] origin/[远程分支名] // 本地创建分支关联远端分支
// 修改代码
git add -A // 添加所有[新增][修改][删除]内容
git commit -m "注释内容" // 预提交，进行lint检测
git commit -m "注释内容" -n // 提交代码，保存本地分支
git checkout [主分支] // 切换主分支
git pull // 拉去主分支代码，此时本地主分支代码为最新代码，本地开发分支有所有修改的代码
git checkout [本地开发分支] // 切回本地开发分支，准备rebase
git rebase [主分支] -i HEAD~2 // 将当前分支合并提交到目标分支
// rebase过程可能会出现冲突，解决冲突后继续rebase过程
git rebase [主分支] --continue // 继续rebase过程
git push // 推送远端
```

##### 20200630

git rebase相关

```shell
// 一次提交，可以直接rebase后解决冲突
git rebase [目标分支]
// 如果多次提交，建议使用rebase -i
git rebase -i [目标分支] // 这样写就是把之前所有commit的都合并成一个，即使之前在该分支合并过的commit也会合并，这就导致了之前的冲突可能重新解决一次，这种问题的解决办法是一个功能做完就提交合并，下一个功能另开新的分支
```

#### 202107

##### 20210701

分析Golang中使用匿名成员和Java中继承的差异

```go
// 上层结构体
type BaseUser struct{
    ID int64
}
func (u *BaseUser) GetID() int64{
    return u.ID
}
// 属于BaseUser结构体的方法
func (u *BaseUser) ToString() string{
    return "BaseUser'ID is" + ID
}
// ====================================== 
// 包含了BaseUser结构体的新结构体
type User struct {
    BaseUser // 匿名结构体
    Name string
}
func (u *User) GetName() string{
    return u.Name
}
// 属于User结构体的ToString方法
func (u *User) ToString() string{
    return "User'ID is" + ID
}
```

>   分析上面代码，BaseUser中实现了ToString方法，User中使用了BaseUser的匿名结构体，Golang中没有继承的概念，这种"组合"的结构理解成将匿名结构体中的成员变量和成员方法传递到子类中，子类再重写就只能是属于子类的成员方法，可以调用父类的成员方法，但不能覆盖父类成员方法；

