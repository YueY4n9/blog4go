### 2021

#### 202106

##### 20210621

>   入职幂律智能~开心的Golang开发启程~

##### 20210628

api/http/v1： `handler.go`定义uri与代码的映射、入参校验，调用`Service层`的逻辑写在这里面；`validation.go`定义入参校验的结构体

context：`config.go`、`context,go`配置文件

domain：`domain.go`实现`interface.go`，

microservice：未知

model：未知

router：路由层，程序启动时初始化用到的`路由层`

service：`service.go`实现`interface.go`，service.go里写逻辑调用的其他模块的一个service结构体，实现调用`数据层`的所有逻辑，数据层包含`domain`和`entity`两部分，分别代表DAO层和Entity层，把domain下来操作数据库，得到entity，entity来获取数据库实例中具体信息



>   总结：handle层→service层→domain层

##### 20210629

包中引用多个其他功能同级目录的包导致的重命名规则

>   功能模块名简写+当前目录层级名简写，全部字母小写；
>
>   当不同功能模块简写重复时，后添加的功能模块包使用易懂的简写代替；

```go
import{
    uc "powerlaw.ai/meflow/controller/internal/app/utils/consts/user" // uc表示userconsts
}
```

包中引用系统级别包和自定义包导致的重命名规则

>   系统级别包使用前缀`sys`+包名或缩写
>
>   Golang扩展包使用`go`或扩展包前缀+包名或缩写
>
>   用户自定义包使用原名或缩写，全部字母小写；

```go
import{
    sysctx 	"context"
    
   	gouuid "github.com/satori/go.uuid"
    gomail "gopkg.in/mail.v2"
    
    context "powerlaw.ai/meflow/controller/internal/app/domain/contract/entity"
}
```

包中引用工具包，可以直接重定义命名

>   引用工具包时，即使没有重名包的情况下，对工具包直接重命名，全部字母小写；

```go
import{
    httputils "powerlaw.ai/meflow/controller/internal/app/utils/http" 
}
```

>   结构体中引用到多个其他其他功能同级目录的类型时，参数名使用功能模块名+目录层级名，小驼峰命名（包名中包含多词时以功能为最小单位）
>
>   引用到系统级别包或自定义系统级功能包时，
>
>   当`单词长度≤8`时，参数名可以使用单词全拼；
>
>   当`单词长度＞8`时，参数名使用短命名形式；

```go
type service struct {
    ctx 				*context.AppContext	// AppContext就简写成ctx
    workflowDomain 		workflow.Domain		// workflow长度适宜，使用全拼，且不允许写成workFlow
    bcDomain 			bcd.Domain 			// businesscategory过长，就简写成了bc
}
```

git rebase相关

```shell
git checkout -b [本地开发分支名] origin/[远程分支名] // 本地创建分支关联远端分支
// 修改代码
git add -A // 添加所有[新增][修改][删除]内容
git commit -m "注释内容" // 预提交，进行lint检测
git commit -m "注释内容" -n // 提交代码，保存本地分支
git checkout [主分支] // 切换主分支
git pull // 拉去主分支代码，此时本地主分支代码为最新代码，本地开发分支有所有修改的代码
git checkout [本地开发分支] // 切回本地开发分支，准备rebase
git rebase [主分支] -i HEAD~2 // 将当前分支合并提交到目标分支
// rebase过程可能会出现冲突，解决冲突后继续rebase过程
git rebase [主分支] --continue // 继续rebase过程
git push // 推送远端
```

##### 20200630

git rebase相关

```shell
// 一次提交，可以直接rebase后解决冲突
git rebase [目标分支]
// 如果多次提交，建议使用rebase -i
git rebase -i [目标分支] // 这样写就是把之前所有commit的都合并成一个，即使之前在该分支合并过的commit也会合并，这就导致了之前的冲突可能重新解决一次，这种问题的解决办法是一个功能做完就提交合并，下一个功能另开新的分支
```

#### 202107

##### 20210701

分析Golang中使用匿名成员和Java中继承的差异

```go
// 上层结构体
type BaseUser struct{
    ID int64
}
func (u *BaseUser) GetID() int64{
    return u.ID
}
// 属于BaseUser结构体的方法
func (u *BaseUser) ToString() string{
    return "BaseUser'ID is" + ID
}
// ====================================== 
// 包含了BaseUser结构体的新结构体
type User struct {
    BaseUser // 匿名结构体
    Name string
}
func (u *User) GetName() string{
    return u.Name
}
// 属于User结构体的ToString方法
func (u *User) ToString() string{
    return "User'ID is" + ID
}
```

>   分析上面代码，BaseUser中实现了ToString方法，User中使用了BaseUser的匿名结构体，Golang中没有继承的概念，这种"组合"的结构理解成将匿名结构体中的成员变量和成员方法传递到子类中，子类再重写就只能是属于子类的成员方法，可以调用父类的成员方法，但不能覆盖父类成员方法；

##### 20210705

>   entity层不要依赖entity层的结构体，防止循环依赖，可以依赖于common的entity层

>   构建结构体对象直接使用{}初始化，不用使用new()

>   更新接口要执行事务，对数据加锁

>   `解决完一个小问题也需要回头检查和验证是否正确`

##### 20210706

>   考虑一块代码需要放到合适的位置，还挺重要的，可以避免不必要的代码重复执行

>避免变量名歧义

>   `做完一定要测一测，千万别嫌麻烦！！！`

##### 20210707

>   定义结构体接收请求参数的时候，注意：
>
>   uri是对应地址中的两个/中间夹着的那个，对应校验ShouldBindUri
>
>   form是?后面开始的那些，对应校验ShouldBindQuery
>
>   json是body里面的，对应校验ShouldBindJSON

>   MVP：最简化可行性版本

-   [ ] 写Golang原生的http接口请求和响应，以此来理解Go处理请求的底层实现

##### 20210708

>   Synth账号/密码：`synth/synth@powerlaw4506`

>   一般启动项要置于日志管理工具之后，否则会有日志无法捕捉异常这种问题

完成启动项启动时的panic异常在阿里云日志的捕获

##### 20210709

>   解决一个bug，生成两个bug？？？认真开发

##### 20210712

-   [x] 修复编辑合同模板时更新人字段未返回的bug
-   [x] 修复添加成员不输入手机号报参数不合法bug

##### 20210713

>   做需求之前了解需求文档

##### 20210714

-   [x] 获取审批通知列表接口

-   [x] 通知已读接口

-   [x] 通知全部已读接口

-   [x] 获取通知数量接口

##### 20210715

>   事务执行更新语句一定要对查询的数据结果进行判断是否存在，否则获取锁会卡住然后直到获取锁超时！！！

-   [x] 审批详情接口
-   [x] 获取审批进程接口

>   喝了一罐魔爪一晚上没睡着，真就离谱！

##### 20210716

>   rebase之后代码会自动合并，这时出现的冲突并不会被检测，所以rebase之后需要再次make proj来检测代码。
>
>   可以总结为，任意一次push之前，进行make proj。（commit之前的make proj是为了不反复的reset自己commit的代码）

~~中耳炎的折磨~~

##### 20210719

-   [x] 审批进程加签接口

##### 20210720

>   写代码的过程中一定要把自己需要之后修改的地方记在小本本上，否则之后又要重新找位置，很蓝的啦！

>   返回标准库的error必须加入到栈中，否则不会返回err栈！

完善了之前写的接口问题和bug

##### 20210721

解决了一天的接口bug，现在明确了一点，就是接口写完一定要好好复盘，因为真的会有很多在写代码中和写代码之前考虑不到的问题，

>   写完代码要`好好复盘`，从中吸取经验和教训

>   写代码之前花最少的时间来简单了解需求，更多的时间放在写代码过程中思考和写完代码之后的复盘时间，这样可能是对现在的水平效率最高的方式

-   [ ] 解决model和domain区别这个问题
-   [ ] 解决rebase -i HEAD~2的合并问题

##### 20210722

>   项目Git push 之前一定要执行make proj，这会决定别人拉去后的代码是否是有问题的。

>   对直接查询出来的数据也需要判断nil，经典空指针错误不可以再次出现！

>   请假记得和技术负责人都打声招呼啥的

`周四周会`：

[设计文档最佳实践](https://confluence.milvzn.com/pages/viewpage.action?pageId=23236421)

[k8s本地开发指南](https://confluence.milvzn.com/pages/viewpage.action?pageId=23236334)

写好代码并不是需要程序包用的多好，更多是想法是否能到那个点，设计文档就可以提升这种水平。（但我觉得这种能力对于水平相对较低的开发来说极难提升，所以暂时更应该花时间来提升自己的开发水平）`^_^`

要改进的地方：
	把需求文档嵌在设计文档中，就挺好找的
	把每周的会议纪要记下，每周轮着做`Q^Q`
	请假和技术负责人打招呼，考虑的因素有排期和人员安排

##### 20210723

快活周五！`^_^`

##### 20210726

>   err判断nil和对象的判断nil必须好好对照！否则会做一部分无用功！`QAQ`

##### 20210728

>   如果能判断切片长度，需要写定长度避免扩容带来的性能损耗

#### 202108

##### 20210802

>   控制饮食，控制体重，增强锻炼，自律自强！

努力改变自己目前的编程思想，成为一名拥有较强独立思考能力的架构者。

##### 20210803

File表中is_temp字段的修改情景：

1.  审批同意接口、审批拒绝接口，都会重新上传新文件
2.  模板创建接口，会上传文件
3.  模板修改接口，会取消文件关联，再重新上传文件
4.  模板删除接口，会取消文件关联
5.  合同审批直接发起接口，会上传文件
6.  合同审批暂存接口，会上传文件

##### 20210804

-   [ ] 了解下mongo事务的级别；问题来自于：先开启mongo的事务，插入数据后不能对不存在的集合插入数据

##### 20210811

>   mongoDB通过`_id`查询时，需要将`string类型的_id`转换成`ObjectID类型的_id`，才能实现mongoDB的查询。个人认为这个地方可以进行封装优化

